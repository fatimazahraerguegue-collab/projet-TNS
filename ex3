import numpy as np
import matplotlib.pyplot as plt

# --- PARAMÈTRES GLOBAUX ---
F1 = 2000.0  # Fréquence 1 (Hz) - A1=5
A1 = 5.0
F2 = 5000.0  # Fréquence 2 (Hz) - A2=1 (Cause de l'aliasing)
A2 = 1.0
Fs = 8000.0  # Fréquence d'échantillonnage (Hz)
Fc = 4000.0  # Fréquence de coupure du LPF (Hz)

F_nyquist = Fs / 2
F_alias = abs(Fs - F2)
print(f"Q3: Fréquence de Nyquist: {F_nyquist/1000} kHz. Aliasing de F2={F2} Hz sur {F_alias} Hz.")

# =================================================================
# 3.a. Spectre du signal échantillonné (jusqu'à 20 kHz)
# =================================================================

def calculate_sampled_spectrum_q3(F1, A1, F2, A2, Fs, F_max_plot):
    """Calcule les fréquences images et leurs amplitudes pour le signal échantillonné, incluant l'aliasing."""
    
    components = [
        (F1, A1 / 2),
        (F2, A2 / 2)
    ]
    
    F_max_sig = max(F1, F2)
    k_max = int(np.ceil((F_max_plot + F_max_sig) / Fs))
    
    # Utilisation d'un dictionnaire pour gérer la superposition (aliasing) des amplitudes
    sampled_spectrum = {}  # {Fréquence: Somme_Amplitudes_Bilatérales}

    # Calcul des images pour chaque composante (k*Fs +/- Fx)
    for k in range(k_max + 1):
        for Fx, Ax_bilat in components:
            
            # Fréquence positive: k*Fs + Fx
            f_pos = k * Fs + Fx
            # Fréquence négative (repliée): |k*Fs - Fx|
            f_neg = abs(k * Fs - Fx)
            
            # Ajout des images dans la limite positive [0, 20 kHz]
            for f in [f_pos, f_neg]:
                if f <= F_max_plot and f != 0:
                    # L'aliasing est géré ici: si une image se superpose à une autre raie (ex: F2 à 3 kHz),
                    # les amplitudes bilatérales sont additionnées automatiquement dans le dictionnaire.
                    sampled_spectrum[f] = sampled_spectrum.get(f, 0.0) + Ax_bilat
    
    # Préparer les données pour le tracé (trié)
    frequencies = np.array(sorted(sampled_spectrum.keys()))
    amplitudes = np.array([sampled_spectrum[f] for f in frequencies])
    
    return frequencies, amplitudes


def plot_sampled_spectrum_q3a(F1, A1, F2, A2, Fs):
    """Génère le tracé du spectre échantillonné avec aliasing."""
    
    F_max_plot = 20000.0  # Limite de tracé (Hz)
    
    frequencies, amplitudes = calculate_sampled_spectrum_q3(F1, A1, F2, A2, Fs, F_max_plot)
    
    print("\n--- 3.a. Spectre du signal échantillonné (Unilatéral, 0 à 20 kHz) ---")
    print("Fréquences images (Hz) et Amplitude Bilatérale Totale:")
    for f, a in zip(frequencies, amplitudes):
        print(f"F: {f:7.1f} Hz, A: {a}")
    
    # 3. Création du tracé
    plt.figure(figsize=(10, 5))
    plt.stem(frequencies, amplitudes, basefmt="k-", linefmt="r-", markerfmt="ro")
    
    plt.title(f'3.a. Spectre Échantillonné avec Aliasing ($F_s={Fs/1000}$ kHz)')
    plt.xlabel('Fréquence (Hz)')
    plt.ylabel('Amplitude (A/2)')
    plt.xlim(0, F_max_plot + 1000)
    plt.xticks(np.arange(0, F_max_plot + 1000, 2000))
    plt.grid(True, linestyle='--')
    plt.ylim(0, max(amplitudes) + 0.5)
    plt.show()

# Exécution de la question 3.a
plot_sampled_spectrum_q3a(F1, A1, F2, A2, Fs)
# 


# =================================================================
# 3.b. Spectre du signal récupéré (LPFi, Fc=4 kHz)
# =================================================================

def plot_recovered_spectrum_q3b(F1, A1, F2, A2, Fs, Fc):
    """Simule et trace le spectre du signal récupéré par le LPF après aliasing."""
    
    F_max_plot_sampled = 20000.0
    frequencies_sampled, amplitudes_sampled = calculate_sampled_spectrum_q3(F1, A1, F2, A2, Fs, F_max_plot_sampled)
    
    recovered_spectrum = {} # {Fréquence: Amplitude_Unilatérale}

    # 1. Application du LPF (Ne garde que les fréquences < Fc)
    print("\n--- 3.b. Spectre du signal récupéré (LPFi Fc=4 kHz) ---")
    print(f"LPF de coupure à Fc={Fc/1000} kHz. La fréquence aliasée (3 kHz) sera conservée.")
    
    for f, a_bilat in zip(frequencies_sampled, amplitudes_sampled):
        if f < Fc:
            # Pour la reconstruction, l'amplitude unilatérale = 2 * amplitude bilatérale
            A_unilat = 2 * a_bilat
            recovered_spectrum[f] = A_unilat

    # Préparer les données pour le tracé (trié)
    frequencies = np.array(sorted(recovered_spectrum.keys()))
    amplitudes = np.array([recovered_spectrum[f] for f in frequencies])
    
    print("Fréquences Récupérées (Hz) et Amplitude Unilatérale:")
    for f, a in zip(frequencies, amplitudes):
        print(f"F: {f:7.1f} Hz, A: {a}")
    
    # 2. Création du tracé
    plt.figure(figsize=(8, 4))
    plt.stem(frequencies, amplitudes, basefmt="k-", linefmt="g-", markerfmt="go")
    
    plt.title(f'3.b. Spectre du Signal Récupéré (Distorsion par Aliasing)')
    plt.xlabel('Fréquence (Hz)')
    plt.ylabel('Amplitude (A)')
    plt.xlim(0, Fc + 1000)
    plt.grid(True, linestyle='--')
    plt.ylim(0, max(amplitudes) + 1.0)
    plt.show()

# Exécution de la question 3.b
plot_recovered_spectrum_q3b(F1, A1, F2, A2, Fs, Fc)
#
